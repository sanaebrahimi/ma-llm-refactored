"""Scoring and contribution utilities."""

from __future__ import annotations

from typing import Dict, List, Sequence, Tuple

import numpy as np

from .parsing import extract_fraction_or_float_values, parse_numeric_score


def calculate_cosine(vector1: Sequence[float], vector2: Sequence[float]) -> float:
    """Compute cosine similarity for two vectors."""

    a = np.array(vector1)
    b = np.array(vector2)
    if a.shape != b.shape:
        raise ValueError("Input vectors must have the same length")
    return float(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)))


def calculate_contribution(
    judge,
    communication: Sequence[str],
    responses: Sequence[str],
    final_response: str,
) -> Dict[str, float]:
    """Ask judge model for per-agent contribution values."""

    n = len(responses)
    history = ".\n".join(communication)
    history = f"{history}\nfinal response of the group generated by the coordinator: {final_response}"

    judge.system_template = (
        f"You are provided with communication history among {n} members of a group. "
        f"Return a list of size {n} of floats between 0 and 1 that sum to 1, where each index "
        "maps to the same-index agent contribution. Return list format only."
    )
    raw_scores = judge.get_score(f"Here is the history of communication among members: {history}")
    values = extract_fraction_or_float_values(raw_scores)

    if len(values) < n:
        values += [0.0] * (n - len(values))
    values = values[:n]

    return {f"agent {idx} {response}": float(values[idx]) for idx, response in enumerate(responses)}


def update_weights(
    raw_score,
    weights: Sequence[float],
    shapley_vals: Dict[str, float],
    learning_rate: float = 0.1,
) -> Tuple[np.ndarray, float]:
    """Update credibility weights using reward and per-agent contributions."""

    score = parse_numeric_score(raw_score)
    updated: List[float] = []

    for idx, contribution in enumerate(shapley_vals.values()):
        updated.append(float(weights[idx]) * (1.0 + score * float(contribution) * learning_rate))

    vector = np.array(updated)
    norm = np.linalg.norm(vector)
    if norm == 0:
        return np.array(weights, dtype=float), score
    return vector / norm, score
